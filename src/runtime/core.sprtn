(structure
 ;; Primitive values
 (declare-primval nil)
 (declare-primval true)
 (declare-primval false)

 ;; Boolean
 (declare-primop (not x))

 (define (not x)
   (asm (primop-app 'not x)))

 ;; Equality
 (declare-primop (equal? a b))
 (declare-primop (eq? a b))
 (declare-primop (= a b))
 (declare-primop (< a b))
 (declare-primop (<= a b))
 (declare-primop (> a b))
 (declare-primop (>= a b))

 (define (equal? a b)
   (asm (primop-app 'equal? a b)))

 (define (eq? a b)
   (asm (primop-app 'eq? a b)))

 (define (= a b)
   (asm (primop-app '= a b)))

 (define (< a b)
   (asm (primop-app '< a b)))

 (define (<= a b)
   (asm (primop-app '<= a b)))

 (define (> a b)
   (asm (primop-app '> a b)))

 (define (>= a b)
   (asm (primop-app '>= a b)))

 ;; Math
 (declare-primop (zero? a))
 (declare-primop (* a b))
 (declare-primop (+ a b))
 (declare-primop (- a b))
 (declare-primop (/ a b))
 (declare-primop (modulo a b))
 (declare-primop (quotient a b))
 (declare-primop (remainder a b))
 (declare-primop (random))

 (define (zero? x)
   (asm (primop-app 'zero? x)))

 (define (* a b)
   (asm (primop-app '* a b)))

 (define (+ a b)
   (asm (primop-app '+ a b)))

 (define (- a b)
   (asm (primop-app '- a b)))

 (define (/ a b)
   (asm (primop-app '/ a b)))

 (define (modulo a b)
   (asm (primop-app 'modulo a b)))

 (define (quotient a b)
   (asm (primop-app 'quotient a b)))

 (define (remainder a b)
   (asm (primop-app 'remainder a b)))

 (define (random)
   (asm (primop-app 'random)))

 ;; List
 (declare-primop (nil? x))
 (declare-primop (car l))
 (declare-primop (cdr l))
 (declare-primop (cons a b))

 (define (nil? l)
   (asm (primop-app 'nil? l)))

 (define (empty? l)
   (nil? l))

 (define (car l)
   (asm (primop-app 'car l)))

 (define (cdr l)
   (asm (primop-app 'cdr l)))

 (define (cadr l)
   (car (cdr l)))

 (define (caddr l)
   (cdr (cdr l)))

 (define (cons a b)
   (asm (primop-app 'cons a b)))

 (define (append a b)
   (if (nil? a)
       b
       (cons (car a)
             (append (cdr a)
                     b))))

 (define (concat a b)
   (append a b))

 ;; Mutable refs
 (declare-primop (ref r))
 (declare-primop (deref r))
 (declare-primop (assign! r v))

 (define (ref a)
   (asm (primop-app 'ref a)))

 (define (deref r)
   (asm (primop-app 'deref r)))

 (define (assign! r v)
   (asm (primop-app 'assign! r v)))

 ;; IO
 (declare-primop (display x))

 (define (display x)
   (asm (primop-app 'display x)))

 (define (newline)
   (display "\n"))

 ;; Continuations
 ;; NOTE Needed to translate closures into continuations.
 ;; FIXME Alternatively, this should be replaced by a continuation AST node that is passed through the whole compiler unchanged.
 (declare-primval yield)

 (declare-primop (push-delimited-continuation! c))
 (declare-primop (pop-delimited-continuation!))

 ;; NOTE Needed to get the lexical continuation value before it actually exists in the AST.
 ;; FIXME Inlining might change the lexical continuation, but that ought to be fine, right?
 (declare-primop (&current-continuation))

 (define (push-delimited-continuation! c)
   (asm (primop-app 'push-delimited-continuation! c)))

 (define (pop-delimited-continuation!)
   (asm (primop-app 'pop-delimited-continuation!)))

 (define (call/current-continuation f)
   (let ((cc (asm (primop-app '&current-continuation))))
     ;; NOTE cc is passed here implicitly as well.
     (f (lambda (v)
          (yield cc v)))))

 (define (call/reset f)
   (let ((cc (asm (primop-app '&current-continuation))))
     (push-delimited-continuation! cc)
     (let ((result (f)))
       (yield (pop-delimited-continuation!) result))))

 (define (call/shift f)
   (let* ((cc (asm (primop-app '&current-continuation))))
     (let ((result (f (lambda (v)
                        (let ((ct2 (asm (primop-app '&current-continuation))))
                          (push-delimited-continuation! ct2)
                          (yield cc v))))))
       (yield (pop-delimited-continuation!)
              result))))

 ;; Exceptions
 (declare-primop (current-task))
 (declare-primop (uproc-error-handler x))
 (declare-primop (set-uproc-error-handler! x))

 (define (current-task)
   (asm (primop-app 'current-task)))

 (define (uproc-error-handler uproc)
   (asm (primop-app 'uproc-error-handler uproc)))

 (define (set-uproc-error-handler! uproc handler)
   (asm (primop-app 'set-uproc-error-handler! uproc handler)))

 (define (call/handler handler f)
   (let* ((cc (asm (primop-app '&current-continuation)))
          (curr-task (current-task))
          (curr-handler (uproc-error-handler curr-task)))
     (set-uproc-error-handler! curr-task
                               (lambda (error restart)
                                 (set-uproc-error-handler! curr-task curr-handler)
                                 (let ((result (handler error restart)))
                                   (yield cc result))))
     (let ((result (f)))
       (set-uproc-error-handler! curr-task curr-handler)
       (yield cc result))))

 (define (raise e)
   (let* ((cont (asm (primop-app '&current-continuation)))
          (curr-task (current-task))
          (curr-handler (uproc-error-handler curr-task))
          (restart (lambda (v)
                     (set-uproc-error-handler! curr-task curr-handler)
                     (yield cont v))))
     ;; NOTE Cont is going to be passed implicitly.
     (curr-handler e restart)))

 ;; Actor model
 ;; FIXME Needed for recv to yield execution before recurring.
 (declare-primval recur)
 (declare-primop (self))
 (declare-primop (recv))
 (declare-primop (send pid msg))
 (declare-primop (spawn f))
 (declare-primop (sleep t))
 (declare-primop (task-info))
 (declare-primop (monitor t))

 (define (self)
   (asm (primop-app 'self)))

 (define (recv)
   (let* ((cc (asm (primop-app '&current-continuation)))
          (r (asm (primop-app 'recv))))
     (if (car r)
         (yield cc (cdr r))
         ;; FIXME Required as otherwise it'll spin without ever yielding in case there is no message available.
         (recur recv))))

 (define (send pid msg)
   (asm (primop-app 'send pid msg)))

 (define (spawn fun)
   (asm (primop-app 'spawn fun)))

 (define (sleep t)
   (let ((cc (asm (primop-app '&current-continuation))))
     (asm (primop-app 'sleep t))
     (yield cc t)))

 (define (task-info)
   (asm (primop-app 'task-info)))

 (define (monitor timeout)
   (task-info)
   (sleep timeout)
   (monitor timeout))

 ;; RBS
 (declare-primop (assert! fact))
 (declare-primop (signal! fact))
 (declare-primop (retract! fact))
 (declare-primop (select query))
 (declare-primop (notify-whenever pid query))

 (define (assert! fact)
   (asm (primop-app 'assert! fact)))

 (define (signal! fact)
   (asm (primop-app 'signal! fact)))

 (define (retract! fact)
   (asm (primop-app 'retract! fact)))

 (define (select pattern)
   (asm (primop-app 'select pattern)))

 (define (notify-whenever pid pattern)
   (asm (primop-app 'notify-whenever pid pattern)))
)

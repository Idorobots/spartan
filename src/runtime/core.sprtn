(structure

 (define nil '())
 (define true (asm (primop-app 'eq? nil nil)))
 (define false (asm (primop-app 'eq? nil 23)))

 ;; Boolean
 (define (not x)
   (if x false true))

 ;; Mutable refs
 (declare-primitive (ref r))
 (declare-primitive (deref r))
 (declare-primitive (assign! r v))

 ;; Equality
 (declare-primitive (equal? a b))
 (declare-primitive (eq? a b))
 (declare-primitive (= a b))
 (declare-primitive (< a b))
 (declare-primitive (<= a b))
 (declare-primitive (> a b))
 (declare-primitive (>= a b))

 ;; Math
 (declare-primitive (* a b))
 (declare-primitive (+ a b))
 (declare-primitive (- a b))
 (declare-primitive (/ a b))
 (declare-primitive (modulo a b))
 (declare-primitive (quotient a b))
 (declare-primitive (remainder a b))
 (declare-primitive (random))

 (define (zero? x)
   (= x 0))

 ;; List
 (declare-primitive (car l))
 (declare-primitive (cdr l))
 (declare-primitive (cons a b))

 (define (nil? l)
   (eq? l nil))

 (define empty? nil?)

 (define (cadr l)
   (car (cdr l)))

 (define (caddr l)
   (cdr (cdr l)))

 (define (append a b)
   (if (nil? a)
       b
       (cons (car a)
             (append (cdr a)
                     b))))

 (define (concat a b)
   (append a b))

 ;; IO
 (declare-primitive (display x))

 (define (newline)
   (display "\n"))

 ;; Continuations
 ;; NOTE Needed to translate closures into continuations.
 ;; FIXME Alternatively, this should be replaced by a continuation AST node that is passed through the whole compiler unchanged.
 ;; FIXME Pulls it into the structure scope and overrides the bootstrapped value.
 ;;(declare-primitive yield)

 (declare-primitive (current-task))
 (declare-primitive (uproc-delimited-continuations p))
 (declare-primitive (set-uproc-delimited-continuations! p c))

 ;; NOTE Needed to get the lexical continuation value before it actually exists in the AST.
 ;; FIXME Inlining might change the lexical continuation, but that ought to be fine, right?
 ;; FIXME This isn't an actual primop.
 ;;(declare-primitive (&current-continuation))

 (define (push-delimited-continuation! c)
   (let ((task (current-task)))
     (set-uproc-delimited-continuations! task
                                         (cons c (uproc-delimited-continuations task)))))

 (define (pop-delimited-continuation!)
   (let* ((task (current-task))
          (stack (uproc-delimited-continuations task)))
     (set-uproc-delimited-continuations! task (cdr stack))
     (car stack)))

 (define (call/current-continuation f)
   (let ((cc (asm (primop-app '&current-continuation))))
     ;; NOTE cc is passed here implicitly as well.
     (f (lambda (v)
          (yield cc v)))))

 (define (call/reset f)
   (let* ((cc (asm (primop-app '&current-continuation))))
     (push-delimited-continuation! cc)
     (let ((result (f)))
       (yield (pop-delimited-continuation!) result))))

 (define (call/shift f)
   (let* ((cc (asm (primop-app '&current-continuation))))
     (let ((result (f (lambda (v)
                        (let ((ct2 (asm (primop-app '&current-continuation))))
                          (push-delimited-continuation! ct2)
                          (yield cc v))))))
       (yield (pop-delimited-continuation!)
              result))))

 ;; Exceptions
 (declare-primitive (uproc-error-handler p))
 (declare-primitive (set-uproc-error-handler! p h))

 (define (call/handler handler f)
   (let* ((cc (asm (primop-app '&current-continuation)))
          (curr-task (current-task))
          (curr-handler (uproc-error-handler curr-task)))
     (set-uproc-error-handler! curr-task
                               (lambda (error restart)
                                 (set-uproc-error-handler! curr-task curr-handler)
                                 (let ((result (handler error restart)))
                                   (yield cc result))))
     (let ((result (f)))
       (set-uproc-error-handler! curr-task curr-handler)
       (yield cc result))))

 (define (raise e)
   (let* ((cont (asm (primop-app '&current-continuation)))
          (curr-task (current-task))
          (curr-handler (uproc-error-handler curr-task))
          (restart (lambda (v)
                     (set-uproc-error-handler! curr-task curr-handler)
                     (yield cont v))))
     ;; NOTE Cont is going to be passed implicitly.
     (curr-handler e restart)))

 ;; Actor model
 ;; FIXME Needed for recv to yield execution before recurring.
 ;; FIXME Pulls it into the structure scope and then tries to override the bootstrapped value.
 ;;(declare-primitive recur)
 (declare-primitive (send pid msg))
 (declare-primitive (spawn f))
 (declare-primitive (task-info))
 (declare-primitive (uproc-pid p))
 (declare-primitive (inc-uproc-rtime! p t))

 (declare-primitive (uproc-state p))
 (declare-primitive (set-uproc-state! p s))
 (declare-primitive (uproc-dequeue-msg! p))
 (declare-primitive (uproc-enqueue-msg! p m))

 (define (self)
   (uproc-pid (current-task)))

 (define (recv)
   (let* ((cc (asm (primop-app '&current-continuation)))
          (curr-task (current-task)))
     (if (uproc-msg-queue-empty? curr-task)
         (do (set-uproc-state! curr-task 'waiting-4-msg)
             ;; FIXME Required as otherwise it'll spin without ever yielding in case there is no message available.
             (recur recv))
         (yield cc (uproc-dequeue-msg! curr-task)))))

 (define (sleep t)
   (let ((cc (asm (primop-app '&current-continuation))))
     (inc-uproc-rtime! (current-task) t)
     (yield cc t)))

 (define (monitor timeout)
   (task-info)
   (sleep timeout)
   (monitor timeout))

 ;; RBS
 (declare-primitive (assert! fact))
 (declare-primitive (signal! fact))
 (declare-primitive (retract! fact))
 (declare-primitive (select query))
 (declare-primitive (notify-whenever pid query))

)

(structure

 (define nil '())
 (define true (asm (primop-app 'eq? nil nil)))
 (define false (asm (primop-app 'eq? nil 23)))

 ;; Boolean
 (define (not x)
   (if x false true))

 ;; Mutable refs
 (declare-primitive (ref r))
 (declare-primitive (deref r))
 (declare-primitive (assign! r v))

 ;; Equality
 (declare-primitive (equal? a b))
 (declare-primitive (eq? a b))
 (declare-primitive (= a b))
 (declare-primitive (< a b))
 (declare-primitive (<= a b))
 (declare-primitive (> a b))
 (declare-primitive (>= a b))

 ;; Math
 (declare-primitive (* a b))
 (declare-primitive (+ a b))
 (declare-primitive (- a b))
 (declare-primitive (/ a b))
 (declare-primitive (modulo a b))
 (declare-primitive (quotient a b))
 (declare-primitive (remainder a b))
 (declare-primitive (random))

 (define (zero? x)
   (= x 0))

 ;; List
 (declare-primitive (car l))
 (declare-primitive (cdr l))
 (declare-primitive (cons a b))

 (define (nil? l)
   (eq? l nil))

 (define empty? nil?)

 (define (cadr l)
   (car (cdr l)))

 (define (caddr l)
   (cdr (cdr l)))

 (define (append a b)
   (if (nil? a)
       b
       (cons (car a)
             (append (cdr a)
                     b))))

 (define (concat a b)
   (append a b))

 (define (map f l)
   (if (empty? l)
       '()
       (cons (f (car l))
             (map f (cdr l)))))

 (define (foldr f z l)
   (if (empty? l)
       z
       (f (car l)
          (foldr f z (cdr l)))))

 (define (foldl f z l)
   (if (empty? l)
       z
       (foldl f
              (f (car l) z)
              (cdr l))))

 ;; IO
 (declare-primitive (display x))

 (define (newline)
   (display "\n"))

 ;; Continuations

 ;; FIXME These arent't actual primops.
 ;; NOTE Needed to get the lexical continuation value before it actually exists in the AST.
 ;; (declare-primitive (&current-continuation))
 ;; (declare-primitive (&yield-cont-immediate cc v))

 ;; FIXME Must be defined in bootstrap in order to avoid a double yield vio the explicit and then implicit continuation.
 ;; (define (yield cc v)
 ;;   ;; NOTE Avoids the kont-counter optimization which can sometimes lead to tight loops not yielding fast enough.
 ;;   (asm (primop-app '&yield-cont-immediate cc v)))

 ;; FIXME Overrides the bootstrapped-value.
 ;; (declare-primitive (yield cc v))

 (define (nice)
   ;; NOTE This makes sure to yield the continuation, even thoug it doesn't modify the continuation.
   (let ((cc (asm (primop-app '&current-continuation))))
     (yield cc '())))

 (declare-primitive (current-task))
 (declare-primitive (uproc-delimited-continuations p))
 (declare-primitive (set-uproc-delimited-continuations! p c))

 (define (push-delimited-continuation! c)
   (let ((task (current-task)))
     (set-uproc-delimited-continuations! task
                                         (cons c (uproc-delimited-continuations task)))))

 (define (pop-delimited-continuation!)
   (let* ((task (current-task))
          (stack (uproc-delimited-continuations task)))
     (set-uproc-delimited-continuations! task (cdr stack))
     (car stack)))

 (define (call/current-continuation f)
   (let ((cc (asm (primop-app '&current-continuation))))
     ;; NOTE cc is passed here implicitly as well.
     (f (lambda (v)
          (yield cc v)))))

 (define (call/reset f)
   (let* ((cc (asm (primop-app '&current-continuation))))
     (push-delimited-continuation! cc)
     (let ((result (f)))
       (yield (pop-delimited-continuation!) result))))

 (define (call/shift f)
   (let* ((cc (asm (primop-app '&current-continuation))))
     (let ((result (f (lambda (v)
                        (let ((ct2 (asm (primop-app '&current-continuation))))
                          (push-delimited-continuation! ct2)
                          (yield cc v))))))
       (yield (pop-delimited-continuation!) result))))

 ;; Exceptions
 (declare-primitive (uproc-error-handler p))
 (declare-primitive (set-uproc-error-handler! p h))

 (define (call/handler handler f)
   (let* ((cc (asm (primop-app '&current-continuation)))
          (curr-task (current-task))
          (curr-handler (uproc-error-handler curr-task)))
     (set-uproc-error-handler! curr-task
                               (lambda (error restart)
                                 (set-uproc-error-handler! curr-task curr-handler)
                                 (let ((result (handler error restart)))
                                   (yield cc result))))
     (let ((result (f)))
       (set-uproc-error-handler! curr-task curr-handler)
       (yield cc result))))

 (define (raise e)
   (let* ((cont (asm (primop-app '&current-continuation)))
          (curr-task (current-task))
          (curr-handler (uproc-error-handler curr-task))
          (restart (lambda (v)
                     (set-uproc-error-handler! curr-task curr-handler)
                     (yield cont v))))
     ;; NOTE Cont is going to be passed implicitly.
     (curr-handler e restart)))

 ;; Actor model
 (declare-primitive (uproc-pid p))
 (declare-primitive (uproc-state p))
 (declare-primitive (set-uproc-state! p s))
 (declare-primitive (uproc-priority p))
 (declare-primitive (uproc-vtime p))
 (declare-primitive (uproc-rtime p))
 (declare-primitive (inc-uproc-rtime! p t))
 (declare-primitive (uproc-msg-queue-empty? p))
 (declare-primitive (uproc-dequeue-msg! p))
 (declare-primitive (uproc-enqueue-msg! p m))
 (declare-primitive (find-task pid))
 (declare-primitive (wake-task! p))
 (declare-primitive (spawn-task! p f h))
 (declare-primitive (running-tasks))

 (define (self)
   (uproc-pid (current-task)))

 (define (spawn fun)
   (spawn-task! 100 ;; NOTE Default priority.
                fun
                (lambda (err _)
                  (display ";; Task finished due to an unhandled error: ")
                  (display err)
                  (newline)
                  err)))

 (define (send pid msg)
   (let ((t (find-task pid)))
     ;; FIXME Throw exception when pid isn't found.
     (uproc-enqueue-msg! t msg)
     (wake-task! t)
     pid))

 (define (recv)
   (let* ((cc (asm (primop-app '&current-continuation)))
          (curr-task (current-task)))
     (if (uproc-msg-queue-empty? curr-task)
         (do (set-uproc-state! curr-task 'waiting-4-msg)
             ;; FIXME Required as otherwise it'll spin without ever yielding in case there is no message available.
             ;; FIXME This is caused by the kont-counter optimisation.
             (nice)
             (recv))
         (yield cc (uproc-dequeue-msg! curr-task)))))

 (define (sleep t)
   (let ((cc (asm (primop-app '&current-continuation))))
     (inc-uproc-rtime! (current-task) t)
     (yield cc t)))

 (define (task-info)
   (define (display-line pid prio state vtime rtime)
     ;; FIXME Needs padding.
     (display ";; ")
     (display pid)
     (display " ")
     (display prio)
     (display " ")
     (display state)
     (display " ")
     (display vtime)
     (display " ")
     (display rtime)
     (newline))

   (display-line "PID" "priority" "state" "VTime" "RTime")
   (map (lambda (t)
          (display-line (uproc-pid t)
                        (uproc-priority t)
                        (uproc-state t)
                        (uproc-vtime t)
                        (uproc-rtime t)))
        ;; FIXME Ideally should not be exposed by the scheduler.
        (running-tasks)))

 (define (monitor timeout)
   (task-info)
   (sleep timeout)
   (monitor timeout))

 ;; RBS
 (declare-primitive (assert! fact))
 (declare-primitive (signal! fact))
 (declare-primitive (retract! fact))
 (declare-primitive (select query))
 (declare-primitive (notify-whenever pid query))

)

#lang racket

;; AST utils

(require "nodes.rkt")
(require "match.rkt")
(require "../errors.rkt")
(require "../utils/utils.rkt")

(provide walk-ast traverse-ast map-ast ast-size ast-contains? ast->plain)

;; Walk

(define (walk-ast f expr)
  (traverse-ast (lambda (acc expr)
                  (f expr))
                '()
                expr))

(define (traverse-ast-map f acc lst)
  (if (null? lst)
      '()
      (cons (f acc (car lst))
            (traverse-ast-map f acc (cdr lst)))))

(define (traverse-ast f acc expr)
  (match-ast expr
   ((symbol _)
    expr)
   ((string _)
    expr)
   ((number _)
    expr)
   ((const value)
    (set-ast-const-value expr (f acc value)))
   ((if condition then else)
    (set-ast-node-data expr (make-ast-if-data (f acc condition)
                                              (f acc then)
                                              (f acc else))))
   ((do exprs ...)
    (set-ast-do-exprs expr (traverse-ast-map f acc exprs)))
   ((ast-body exprs ...)
    (set-ast-body-exprs expr (traverse-ast-map f acc exprs)))
   ((lambda formals body)
    (set-ast-node-data expr (make-ast-lambda-data (traverse-ast-map f acc formals)
                                                  (f acc body))))
   ((let bindings body)
    (set-ast-node-data expr (make-ast-let-data (traverse-ast-map f acc bindings)
                                               (f acc body))))
   ((letrec bindings body)
    (set-ast-node-data expr (make-ast-letrec-data (traverse-ast-map f acc bindings)
                                                  (f acc body))))
   ((fix bindings body)
    (set-ast-node-data expr (make-ast-fix-data (traverse-ast-map f acc bindings)
                                               (f acc body))))
   ((binding var val)
    (set-ast-node-data expr (make-ast-binding-data (f acc var)
                                                   (f acc val)
                                                   (ast-binding-complexity expr)
                                                   (ast-binding-self-recursive expr))))
   ((ast-quote value)
    (set-ast-quote-expr expr (f acc value)))
   ((ast-quasiquote value)
    (set-ast-quasiquote-expr expr (f acc value)))
   ((ast-unquote value)
    (set-ast-unquote-expr expr (f acc value)))
   ((ast-unquote-splicing value)
    (set-ast-unquote-splicing-expr expr (f acc value)))
   ((def name value)
    (set-ast-node-data expr (make-ast-def-data (f acc name)
                                               (f acc value))))
   ((app op args ...)
    (set-ast-node-data expr (make-ast-app-data (f acc op)
                                               (traverse-ast-map f acc args))))
   ((primop-app op args ...)
    (set-ast-node-data expr (make-ast-primop-app-data op (traverse-ast-map f acc args))))
   ((list exprs ...)
    (set-ast-list-values expr (traverse-ast-map f acc exprs)))
   ((ast-error value)
    (set-ast-error-expr expr (f acc value)))
   ((ast-location _)
    expr)
   ((ast-syntactic-closure _ _ value)
    (set-ast-syntactic-closure-expr expr (f acc value)))
   (else
    (compiler-bug "Unexpected expression: " expr))))

(define (map-ast f expr)
  (f (traverse-ast map-ast f expr)))

(define (ast-size ast)
  (map-ast (lambda (expr)
             (case (ast-node-type expr)
               ((number symbol string list const quote quasiquote unquote unquote-splicing) 1)
               ((if) (+ (ast-if-condition expr)
                        (ast-if-then expr)
                        (ast-if-else expr)))
               ((do) (apply + (ast-do-exprs expr)))
               ((body) (apply + (ast-body-exprs expr)))
               ((lambda) (ast-lambda-body expr))
               ((let) (foldl +
                             (ast-let-body expr)
                             (ast-let-bindings expr)))
               ((letrec) (foldl +
                                (ast-letrec-body expr)
                                (ast-letrec-bindings expr)))
               ((fix) (foldl +
                             (ast-fix-body expr)
                             (ast-fix-bindings expr)))
               ((binding) (ast-binding-val expr))
               ((app) (foldl +
                             (ast-app-op expr)
                             (ast-app-args expr)))
               ((primop-app) (+ 1 (apply + (ast-primop-app-args expr))))
               ((def) (ast-def-value expr))
               (else 0)))
           ast))

(define (ast-contains? predicate ast)
  (or (predicate ast)
      (match-ast ast
       ((const value)
        (ast-contains? predicate value))
       ((if condition then else)
        (or (ast-contains? predicate condition)
            (ast-contains? predicate then)
            (ast-contains? predicate else)))
       ((do exprs ...)
        (some? (partial ast-contains? predicate) exprs))
       ((ast-body exprs ...)
        (some? (partial ast-contains? predicate) exprs))
       ((lambda formals body)
        (or (ast-contains? predicate body)
            (some? (partial ast-contains? predicate) formals)))
       ((let bindings body)
        (or (ast-contains? predicate body)
            (some? (partial ast-contains? predicate) bindings)))
       ((letrec bindings body)
        (or (ast-contains? predicate body)
            (some? (partial ast-contains? predicate) bindings)))
       ((fix bindings body)
        (or (ast-contains? predicate body)
            (some? (partial ast-contains? predicate) bindings)))
       ((binding var val)
        (or (ast-contains? predicate var)
            (ast-contains? predicate val)))
       ((ast-quote value)
        (ast-contains? predicate value))
       ((ast-quasiquote value)
        (ast-contains? predicate value))
       ((ast-unquote value)
        (ast-contains? predicate value))
       ((ast-unquote-splicing value)
        (ast-contains? predicate value))
       ((def name value)
        (or (ast-contains? predicate name)
            (ast-contains? predicate value)))
       ((app op args ...)
        (or (ast-contains? predicate op)
            (some? (partial ast-contains? predicate) args)))
       ((primop-app op args ...)
        (some? (partial ast-contains? predicate) args))
       ((list exprs ...)
        (some? (partial ast-contains? predicate) exprs))
       ((ast-error value)
        (ast-contains? predicate value))
       ((ast-syntactic-closure _ _ value)
        (ast-contains? predicate value))
       (else
        #f))))

(define (ast->plain ast)
  (map-ast (lambda (expr)
             (case (ast-node-type expr)
               ((number symbol string list) (ast-node-data expr))
               ((if) (list 'if
                           (ast-if-condition expr)
                           (ast-if-then expr)
                           (ast-if-else expr)))
               ((do) (cons 'begin (ast-do-exprs expr)))
               ((body) (cons 'begin (ast-body-exprs expr)))
               ((lambda) (list 'lambda (ast-lambda-formals expr) (ast-lambda-body expr)))
               ((let) (list 'let (ast-let-bindings expr)
                            (ast-let-body expr)))
               ((letrec) (list 'letrec (ast-letrec-bindings expr)
                               (ast-letrec-body expr)))
               ((fix) (list 'fix (ast-fix-bindings expr)
                            (ast-fix-body expr)))
               ((binding) (list (ast-binding-var expr)
                                (ast-binding-val expr)))
               ((const) (list 'quote (ast-const-value expr)))
               ((quote) (list 'quote (ast-quote-expr expr)))
               ((quasiquote) (list 'quasiquote (ast-quasiquote-expr expr)))
               ((unquote) (list 'unquote (ast-unquote-expr expr)))
               ((unquote-splicing) (list 'unquote-splicing (ast-unquote-splicing-expr expr)))
               ((def) (list 'define (ast-def-name expr) (ast-def-value expr)))
               ((app) (list* (ast-app-op expr) (ast-app-args expr)))
               ((primop-app) (list* (ast-primop-app-op expr) (ast-primop-app-args expr)))
               ((<error>) '<error>)
               (else (compiler-bug "Unexpected expression: " expr))))
           ast))
